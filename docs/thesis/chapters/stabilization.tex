\section{Temporal stabilization of clusters}

Dopo la clusterizzazione dobbiamo fare un riassegnamento di colori ai clusters per stabilizzarli nel tempo.
Come si è già detto, l'ordine con cui i clusters vengono decisi ad ogni istante è randomico e l'ordine di scelta dei clusters viene rappresentato da un colore. \\
Quindi, dall'iniziale assegnazione di colori randomica, vogliamo passare ad un'assegnazione di colori dove, due clusters dello stesso colore, da un istante all'altro, abbiano in comune più nodi, ossia più joints, possibili. \\
Questo perchè l'assegnazione randomica porta dei problemi a livello di visualizzazione del grafo, in quanto è possibile che da un istante all'altro, due cluster con molte joints in comune abbiano colore diverso e quindi la visualizzazione nel tempo potrebbe risultare come un continuo switch di colori facendo perdere un'idea di continuità.
\\

Per stabilizzare i cluster nel tempo, e quindi far si che le coppie dei vari clusters colorati da un istante all'altro mantengano il maggior numero di joint in comune, ci riconduciamo al Maximum Perfect Weight Matching. \\     
Abbiamo implementato due algoritmi: uno di Brute Force, in cui calcoliamo i pesi totali di tutte le permutazioni degli assegnamenti possibili di colori e scegliamo l'assegnamento con il peso totale massimo, e l'Hungarian Algorithm, un metodo di ottimizzazione combinatoria che risolve in tempo polinomiale il problema dell'assegnamento. \\
Dato che nel nostro caso il numero di cluster è solitamente piccolo, in alcuni casi risulta essere più efficiente l'algoritmo di Brute Force.

\subsection{Maximum Perfect Weight Matching for bipartite graphs}

 Il Maximum Perfect Weight Matching è un problema di ottimizzazione riguardante i grafi. \\
 I grafi in questione sono bipartiti, ossia i vertici possono essere suddivisi in due insiemi distinti in
modo tale che tutti gli archi del grafo connettano vertici di insiemi diversi, ma non ci siano archi che connettano vertici all’interno dello stesso insieme.
Inoltre, questi grafi sono non diretti, ossia la relazione tra due nodi è bidirezionale, in altre parole, l'arco che collega il nodo A al nodo B implica automaticamente l'esistenza dell'arco che collega il nodo B al nodo A. \\
Nel problema del Maximum Perfect Weight Matching i vertici rappresentano gli elementi da accoppiare e gli archi rappresentano le possibili connessioni tra questi elementi. Ogni arco ha associato un peso che rappresenta il valore o l'importanza dell'accoppiamento tra i vertici connessi. \\
 L'obiettivo è trovare un accoppiamento perfetto, ovvero un insieme di archi in cui ogni nodo è connesso esattamente a un altro nodo, senza sovrapposizioni o nodi isolati, massimizzando il peso totale degli archi nell'accoppiamento.
 Il peso totale è la somma dei pesi degli archi inclusi nell'accoppiamento. \\
 I pesi degli archi vengono raccolti in una matrice che prende il nome di matrice di utilità. \\
 La matrice di utilità sarà una matrice quadrata, dato che il numero di nodi facenti parte dei due insiemi distinti è lo stesso.
Le righe potrebbero rappresentare i nodi facenti parte del primo insieme, mentre le colonne potrebbero rappresentare i nodi facenti parte del secondo insieme, oppure viceversa.
 L'elemento (\textit{i}, \textit{j}) della matrice rappresenta il peso dell'arco che collega il vertice \textit{i} al vertice \textit{j}.
 


\subsubsection{Maximum Perfect Weight Matching: temporal stabilization}
In questo esempio, anzichè avere nodi collegati da archi, avremo una situazione leggermente diversa. \\   
Al posto dei nodi introdotti precedentemente, avremo dei clusters, ossia degli insiemi di nodi, che per noi rappresentano le joints dello scheletro, collegati fra loro da archi.
\\  

Consideriamo i clusters all'istante \textit{t} e i clusters all'istante \textit{t+1} come due insiemi distinti, perciò non esisteranno archi che collegano clusters facenti parte dello stesso insieme. \\
Ogni cluster di un insieme deve essere collegato tramite un arco ad uno ed un solo cluster dell'altro insieme, con l'obbiettivo di massimizzare il peso totale degli archi.
Il peso di un arco è pari al numero di nodi che hanno in comune i due clusters che l'arco in questione sta collegando. \\
Come già detto, a questo punto della pipeline, conosciamo già ad ogni istante le joints che fanno parte dei vari clusters e i colori dei vari clusters, ma vogliamo fare un riassegnamento di colori per stabilizzare la visualizzazione nel tempo.
La clusterizzazione precedente raggruppa le varie joints in clusters e gli assegna un colore random, mentre in questa fase della pipeline ottimizziamo l'assegnazione dei colori. \\
Partiremo perciò analizzando i colori dei clusters all'istante iniziale e sceglieremo l'assegnamento migliore di colori per l'istante successivo.
Ripeteremo questo procedimento iterativamente fino all'ultimo istante.


\subsubsection{Maximum Perfect Weight Matching: mock example}
Consideriamo un caso semplificato per vedere in termini di visualizzazione come funziona il Maximum Perfect Weight Matching e quindi supponiamo di avere all'istante t 9 nodi rappresentati dalle lettere dell'alfabeto dalla A alla I e 3 clusters, mentre all'istante \textit{t+1} gli stessi 9 nodi precedenti e 3 clusters differenti da quelli dell'istante precedente. \\
I colori possibili sono 3, supponiamo che siano per esempio rosso, blu e verde, conosciamo il colore dei clusters all'istante t e vogliamo assegnare i colori ai clusters all'istante \textit{t+1}.\\
Ci sono quindi \textit{3!} possibili assegnamenti di colore. \\
Come già detto, il peso di un arco è equivalente al numero di nodi che hanno in comune quei due clusters che vengono collegati dall'arco in questione. \\
Da questo esempio si può notare che l'assegnamento con peso totale massimo per l'istante \textit{t+1} è quello visivamente più coerente con quello dell'istante \textit{t}.

\includegraphics[width=\textwidth, height=\textheight, keepaspectratio]{graphics/stabilization.jpg}

\begin{figure}[H]
  \centering
  \begin{tikzpicture}[every node/.style={circle, draw, minimum size=0.2cm}]
    \node (A) at (3,0) [fill=blue!50] {A};
    \node (B) at (5,-0.5) [fill=blue!50] {B};

    \node (C) at (7,0) [fill=green] {C};
    \node (D) at (3,-1) [fill=green] {D};
    \node (E) at (5,-1.5) [fill=green] {E};
    \node (F) at (7,-1) [fill=green] {F};
    \node (G) at (3,-2) [fill=green] {G};

    \node (H) at (5,-2.5) [fill=pink] {H};
    \node (I) at (7,-2) [fill=pink] {I};  
  \end{tikzpicture}
\end{figure}

\begin{table}[H]
  \centering
  \begin{tabular}{|c|c|c|c|c|}
    \hline
    Assignment & Blue match & Green match & Pink match & Final cost \\
    \hline
    Assignment & Blue match & Green match & Pink match & 3 \\
    \hline
    Riga 2, Cell 1 & Riga 2, Cell 2 & Riga 2, Cell 3 & Riga 2, Cell 4 & 1 \\
    \hline
    Riga 3, Cell 1 & Riga 3, Cell 2 & Riga 3, Cell 3 & Riga 3, Cell 4 & 6 \\
    \hline
    Riga 4, Cell 1 & Riga 4, Cell 2 & Riga 4, Cell 3 & Riga 4, Cell 4 & 4 \\
    \hline
    Riga 5, Cell 1 & Riga 5, Cell 2 & Riga 5, Cell 3 & Riga 5, Cell 4 & 2 \\
    \hline
    Riga 6, Cell 1 & Riga 6, Cell 2 & Riga 6, Cell 3 & Riga 6, Cell 4 & 2 \\
    \hline
  \end{tabular}
  \caption{Esempio di tabella 7x5.}
  \label{tab:tabella7x5}
\end{table}

\begin{figure}[H]
  \centering
  \begin{minipage}{0.5\textwidth}
    \centering
    \begin{tikzpicture}[every node/.style={circle, draw, minimum size=0.2cm}]
      \node (A) at (3,0) [fill=blue!50] {A};
      \node (B) at (5,-0.5) [fill=blue!50] {B};
  
      \node (C) at (7,0) [fill=green] {C};
      \node (D) at (3,-1) [fill=green] {D};
      \node (E) at (5,-1.5) [fill=green] {E};
      \node (F) at (7,-1) [fill=green] {F};
      \node (G) at (3,-2) [fill=green] {G};
  
      \node (H) at (5,-2.5) [fill=pink] {H};
      \node (I) at (7,-2) [fill=pink] {I};  
    \end{tikzpicture}
  \end{minipage}%
  \begin{minipage}{0.5\textwidth}
    \centering
    \begin{tikzpicture}[every node/.style={circle, draw, minimum size=0.2cm}]
      \node (A) at (3,0) [fill=blue!50] {A};
      \node (B) at (5,-0.5) [fill=blue!50] {B};
      \node (C) at (7,0) [fill=green] {C};
      
      \node (D) at (3,-1) [fill=green] {D};
      \node (E) at (5,-1.5) [fill=green] {E};

      \node (F) at (7,-1) [fill=green] {F};
      \node (G) at (3,-2) [fill=green] {G}; 
      \node (H) at (5,-2.5) [fill=pink] {H};
      \node (I) at (7,-2) [fill=pink] {I};  
    \end{tikzpicture}
    
    \vspace{15pt} % Spazio verticale tra i grafici

    \centering
    \begin{tikzpicture}[every node/.style={circle, draw, minimum size=0.2cm}]
      \node (A) at (3,0) [fill=blue!50] {A};
      \node (B) at (5,-0.5) [fill=blue!50] {B};
      \node (C) at (7,0) [fill=green] {C};
      
      \node (D) at (3,-1) [fill=green] {D};
      \node (E) at (5,-1.5) [fill=green] {E};

      \node (F) at (7,-1) [fill=green] {F};
      \node (G) at (3,-2) [fill=green] {G}; 
      \node (H) at (5,-2.5) [fill=pink] {H};
      \node (I) at (7,-2) [fill=pink] {I};  
    \end{tikzpicture}

    \vspace{15pt}

    \centering
    \begin{tikzpicture}[every node/.style={circle, draw, minimum size=0.2cm}]
      \node (A) at (3,0) [fill=blue!50] {A};
      \node (B) at (5,-0.5) [fill=blue!50] {B};
      \node (C) at (7,0) [fill=green] {C};
      
      \node (D) at (3,-1) [fill=green] {D};
      \node (E) at (5,-1.5) [fill=green] {E};

      \node (F) at (7,-1) [fill=green] {F};
      \node (G) at (3,-2) [fill=green] {G}; 
      \node (H) at (5,-2.5) [fill=pink] {H};
      \node (I) at (7,-2) [fill=pink] {I};  
    \end{tikzpicture}

    \vspace{15pt}

    \centering
    \begin{tikzpicture}[every node/.style={circle, draw, minimum size=0.2cm}]
      \node (A) at (3,0) [fill=blue!50] {A};
      \node (B) at (5,-0.5) [fill=blue!50] {B};
      \node (C) at (7,0) [fill=green] {C};
      
      \node (D) at (3,-1) [fill=green] {D};
      \node (E) at (5,-1.5) [fill=green] {E};

      \node (F) at (7,-1) [fill=green] {F};
      \node (G) at (3,-2) [fill=green] {G}; 
      \node (H) at (5,-2.5) [fill=pink] {H};
      \node (I) at (7,-2) [fill=pink] {I};  
    \end{tikzpicture}

    \vspace{15pt}

    \centering
    \begin{tikzpicture}[every node/.style={circle, draw, minimum size=0.2cm}]
      \node (A) at (3,0) [fill=blue!50] {A};
      \node (B) at (5,-0.5) [fill=blue!50] {B};
      \node (C) at (7,0) [fill=green] {C};
      
      \node (D) at (3,-1) [fill=green] {D};
      \node (E) at (5,-1.5) [fill=green] {E};

      \node (F) at (7,-1) [fill=green] {F};
      \node (G) at (3,-2) [fill=green] {G}; 
      \node (H) at (5,-2.5) [fill=pink] {H};
      \node (I) at (7,-2) [fill=pink] {I};  
    \end{tikzpicture}

    \vspace{15pt}

    \centering
    \begin{tikzpicture}[every node/.style={circle, draw, minimum size=0.2cm}]
      \node (A) at (3,0) [fill=blue!50] {A};
      \node (B) at (5,-0.5) [fill=blue!50] {B};
      \node (C) at (7,0) [fill=green] {C};
      
      \node (D) at (3,-1) [fill=green] {D};
      \node (E) at (5,-1.5) [fill=green] {E};

      \node (F) at (7,-1) [fill=green] {F};
      \node (G) at (3,-2) [fill=green] {G}; 
      \node (H) at (5,-2.5) [fill=pink] {H};
      \node (I) at (7,-2) [fill=pink] {I};  
    \end{tikzpicture}

  \end{minipage}
\end{figure}


\subsection{Brute Force Algorithm}
L'algoritmo di Brute Force può essere una possibile strada per risolvere il problema del MWPM per grafi bipartiti.
Il Brute Force ha una complessità esponenziale, in particolare, la complessità temporale dell'algoritmo cresce in modo esponenziale rispetto al numero di vertici nel grafo.
Questo perché l'algoritmo di Brute Force esamina tutte le possibili combinazioni di abbinamenti perfetti all'interno del grafo bipartito per trovare quello con il peso massimo. \\
Se il grafo ha \textit{n} vertici sia nella prima partizione che nella seconda partizione, ci sono \textit{n}!\ abbinamenti possibili.
Ogni abbinamento richiede \textit{O}(\textit{n}) tempo per essere calcolato, poiché si deve verificare che sia perfetto e quindi calcolare il suo peso totale.
Quindi, la complessità complessiva dell'algoritmo è dell'ordine di \textit{O}(\textit{n}!$\cdot$\textit{n}). \\
Dato che la complessità cresce rapidamente all'aumentare di \textit{n}, diventa rapidamente inattuabile per grafi di grandi dimensioni, ma per il nostro caso questo non è un problema.

A maximum-weight matching problem using an utility matrix can be transformed into a minimum-weight matching problem.
This can be achieved by introducing an auxiliary matrix, referred to as the "cost matrix."
The cost matrix is essentially a duplicate of the utility matrix, but with all its elements negated.

\subsubsection{Brute Force Algorithm summarized}
The operation of the Brute Force algorithm for minimum-weigth matching problems can be summerized in these 3 steps:

\begin{enumerate}
    \item {Compute the cost matrix for the considered bipartite graph with \textit{n} vertoces in each partition.}
    \item {Compute the total cost of all the \textit{n}!\ permutations.}
    \item {Choose the assignment with the lowest total cost.}
\end{enumerate}


\subsubsection{Brute Force Algorithm application}

Let's take for example the following cost matrix and try to apply the Brute Force algorithm for minimum-weigth matching problems:

\begin{table}[H]
    \centering
    \begin{tabular}{|m{0.5cm}|m{0.5cm}|m{0.5cm}|}
      \hline
      108 & 125 & 150 \\
      \hline
      150 & 135 & 175 \\
      \hline
      122 & 148 & 250 \\
      \hline
    \end{tabular}
    \end{table}

Now we compute the total cost of all the \textit{n}!\ permutations: 

\begin{figure}[H]
    \begin{minipage}[b]{0.3\textwidth}
      \centering
      \begin{tabular}{|m{0.5cm}|m{0.5cm}|m{0.5cm}|}
        \hline
        \cellcolor{yellow!25} 108 & 125 & 150 \\
        \hline
        150 & \cellcolor{yellow!25} 135 & 175 \\
        \hline
        122 & 148 & \cellcolor{yellow!25} 250 \\
        \hline
      \end{tabular}
      \caption{Total weight: 493}
      \label{tab:perm1}
    \end{minipage}
    \hfill
    \begin{minipage}[b]{0.3\textwidth}
      \centering
      \begin{tabular}{|m{0.5cm}|m{0.5cm}|m{0.5cm}|}
        \hline
        108 & \cellcolor{yellow!25} 125 & 150 \\
        \hline
        150 & 135 & \cellcolor{yellow!25}175 \\
        \hline
        \cellcolor{yellow!25}122 & 148 & 250 \\
        \hline
      \end{tabular}
      \caption{Total weight: 422}
      \label{tab:perm2}
    \end{minipage}
    \hfill
    \begin{minipage}[b]{0.3\textwidth}
      \centering
      \begin{tabular}{|m{0.5cm}|m{0.5cm}|m{0.5cm}|}
        \hline
        108 & 125 & \cellcolor{yellow!25}150 \\
        \hline
        \cellcolor{yellow!25} 150 &  135 & 175 \\
        \hline
        122 & \cellcolor{yellow!25} 148 & 250 \\
        \hline
      \end{tabular}
      \caption{Total weight: 448}
      \label{tab:perm3}
    \end{minipage}
  \end{figure}
  

\begin{figure}[H]
    \begin{minipage}[b]{0.3\textwidth}
      \centering
      \begin{tabular}{|m{0.5cm}|m{0.5cm}|m{0.5cm}|}
        \hline
        108 & 125 & \cellcolor{yellow!25} 150 \\
        \hline
        150 & \cellcolor{yellow!25} 135 & 175 \\
        \hline
        \cellcolor{yellow!25} 122 & 148 & 250 \\
        \hline
      \end{tabular}
      \caption{Total weight: 407}
      \label{tab:perm1}
    \end{minipage}
    \hfill
    \begin{minipage}[b]{0.3\textwidth}
      \centering
      \begin{tabular}{|m{0.5cm}|m{0.5cm}|m{0.5cm}|}
        \hline
        108 & \cellcolor{yellow!25} 125 & 150 \\
        \hline
        \cellcolor{yellow!25} 150 & 135 & 175 \\
        \hline
        122 & 148 & \cellcolor{yellow!25} 250 \\
        \hline
      \end{tabular}
      \caption{Total weight: 525}
      \label{tab:perm2}
    \end{minipage}
    \hfill
    \begin{minipage}[b]{0.3\textwidth}
      \centering
      \begin{tabular}{|m{0.5cm}|m{0.5cm}|m{0.5cm}|}
        \hline
        \cellcolor{yellow!25} 108 & 125 & 150 \\
        \hline
        150 & 135 & \cellcolor{yellow!25} 175 \\
        \hline
         122 & \cellcolor{yellow!25} 148 & 250 \\
        \hline
      \end{tabular}
      \caption{Total weight: 431}
      \label{tab:perm3}
    \end{minipage}
  \end{figure}
  
We find that the minimum total cost is given by the assignment in Figure 4.  

\subsection{Hungarian Algorithm}

The Hungarian matching algorithm, also called the Kuhn-Munkres algorithm, is a \textit{O}($\textit{n}^3$) algorithm that can be used to find maximum-weight matchings in bipartite graphs with \textit{n} vertices for each partition, which is sometimes called the assignment problem.
A bipartite graph can easily be represented by an utility matrix, where the weights of edges are the entries. \\
Come abbiamo già visto nel Brute Force algorithm, i problemi di maximum-weight perfect matching con la matrice di utilità possono essere trasformati in problemi di minimum-weight perfect matching con la matrice di costo.
Spiegheremo l'Hungarian algorithm applicato ai problemi di minimum-weight matching.
\\

\subsubsection{Hungarian Algorithm summarized}

The operation of the Hungarian algorithm for minimum-weigth matching problems can be summerized in these 6 steps:
\begin{enumerate}
    \item {Compute the cost matrix for the considered bipartite graph with \textit{n} vertices in each partition.}
    \item {Subtract the smallest entry in each row from all the other entries in the row. This will make the smallest entry in the row now equal to 0.}
    \item {Subtract the smallest entry in each column from all the other entries in the column. This will make the smallest entry in the column now equal to 0.}
    \item {Draw lines through the row and columns that have the 0 entries such that the fewest lines possible are drawn.}
    \item {If there are n lines drawn, an optimal assignment of zeros is possible and the algorithm is finished. If the number of lines is less than n, then the optimal number of zeroes is not yet reached. Go to the next step.}
    \item {Find the smallest entry not covered by any line. Subtract this entry from each row that isn’t crossed out, and then add it to each column that is crossed out. Then, go back to Step 3.}
\end{enumerate}

\subsubsection{Hungarian Algorithm application}

Let's take for example the same cost matrix of the Brute Force example and try to apply the Hungarian algorithm for minimum-weigth matching problems:

\begin{table}[H]
\centering
\begin{tabular}{|m{0.5cm}|m{0.5cm}|m{0.5cm}|}
  \hline
  108 & 125 & 150 \\
  \hline
  150 & 135 & 175 \\
  \hline
  122 & 148 & 250 \\
  \hline
\end{tabular}
\end{table}

Subtract the smallest value in each row from the other values in the row:

\begin{table}[H]
\centering
\begin{tabular}{|m{0.5cm}|m{0.5cm}|m{0.5cm}|}
  \hline
  0 & 17 & 42 \\
  \hline
  15 & 0 & 40 \\
  \hline
  0 & 26 & 128 \\
  \hline
\end{tabular}
\end{table}

Now, subtract the smallest value in each column from all other values in the column:

\begin{table}[H]
\centering
\begin{tabular}{|m{0.5cm}|m{0.5cm}|m{0.5cm}|}
  \hline
  0 & 17 & 2 \\
  \hline
  15 & 0 & 0 \\
  \hline
  0 & 26 & 88 \\
  \hline
\end{tabular}
\end{table}

There are 2 lines drawn, and 2 is less than 3, so there is not yet the optimal number of zeroes.

\begin{table}[H]
\centering
\begin{tabular}{|m{0.5cm}|m{0.5cm}|m{0.5cm}|}
  \hline
  \cellcolor{gray!25} 0 & 17 & 2 \\
  \hline
  \cellcolor{gray!25} 15 & \cellcolor{gray!25} 0 & \cellcolor{gray!25} 0 \\
  \hline
  \cellcolor{gray!25} 0 & 26 & 88 \\
  \hline
\end{tabular}
\end{table}

Find the smallest entry not covered by any line. Subtract this entry from each row that isn’t crossed out, and then add it to each column that is crossed out. Then, go back to Step 3.
2 is the smallest entry.
First, subtract from the uncovered rows:

\begin{table}[H]
\centering
\begin{tabular}{|m{0.5cm}|m{0.5cm}|m{0.5cm}|}
  \hline
  \cellcolor{gray!25} -2 & 15 & 0 \\
  \hline
  \cellcolor{gray!25} 15 & \cellcolor{gray!25} 0 & \cellcolor{gray!25} 0 \\
  \hline
  \cellcolor{gray!25} -2 & 24 & 86 \\
  \hline
\end{tabular}
\end{table}

Now add to the covered columns:

\begin{table}[H]
\centering
\begin{tabular}{|m{0.5cm}|m{0.5cm}|m{0.5cm}|}
  \hline
  \cellcolor{gray!25} 0 & 15 & 0 \\
  \hline
  \cellcolor{gray!25} 17 & \cellcolor{gray!25} 0 & \cellcolor{gray!25} 0 \\
  \hline
  \cellcolor{gray!25} 0 & 24 & 86 \\
  \hline
\end{tabular}
\end{table}

Now go back to step 3, drawing lines through the rows and columns that have 0 entries:

\begin{table}[H]
\centering
\begin{tabular}{|m{0.5cm}|m{0.5cm}|m{0.5cm}|}
  \hline
  \cellcolor{gray!25} 0 & \cellcolor{gray!25} 15 & \cellcolor{gray!25} 0 \\
  \hline
  \cellcolor{gray!25} 17 & \cellcolor{gray!25} 0 & \cellcolor{gray!25} 0 \\
  \hline
  \cellcolor{gray!25} 0 & 24 & 86 \\
  \hline
\end{tabular}
\end{table}

There are 3 lines (which is nn), so we are done. The assignment will be where the 0's are in the matrix such that only one 0 per row and column is part of the assignment.

\begin{table}[H]
\centering
\begin{tabular}{|m{0.5cm}|m{0.5cm}|m{0.5cm}|}
  \hline
  0 & 15 & \cellcolor{yellow!25} 0 \\
  \hline
  17 & \cellcolor{yellow!25} 0 & 0 \\
  \hline
  \cellcolor{yellow!25} 0 & 24 & 86 \\
  \hline
\end{tabular}
\end{table}

Replace the original values:

\begin{table}[H]
\centering
\begin{tabular}{|m{0.5cm}|m{0.5cm}|m{0.5cm}|}
  \hline
  108 & 125 & \cellcolor{yellow!25} 150 \\
  \hline
  150 & \cellcolor{yellow!25} 135 & 175 \\
  \hline
  \cellcolor{yellow!25} 122 & 148 & 250 \\
  \hline
\end{tabular}
\end{table}

We find that the minimum total cost is given by this assignment.